<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>stack</title></head>
<body><p>写一个栈，可以查长度，可以添加、删除元素？</p>
<pre><code class='language-python' lang='python'>class Stack(object):
    &quot;&quot;&quot;栈&quot;&quot;&quot;
    def __init__(self):
        &quot;&quot;&quot;初始化&quot;&quot;&quot;
        self.__list = []      # 定义一个列表用于存放数据

    def push(self, data):
        &quot;&quot;&quot;添加一个新的元素data到栈顶&quot;&quot;&quot;
        self.__list.append(data)    # 把列表的尾部作为栈顶

    def pop(self):
        &quot;&quot;&quot;弹出栈顶元素&quot;&quot;&quot;
        return self.__list.pop()    # 从列表尾部出栈操作

    &quot;&quot;&quot;
        也可以把列表头部作为栈顶,如果把列表头部作为栈顶，
        则压栈就是 self.__list.insert(0, data),
        出栈则是self.__list.pop(0)
        此种方式与把列表尾部作为栈顶区别在于，列表尾部操作时间复杂度是O（1），而头部操作时间复杂度是O（n）
    &quot;&quot;&quot;
    def peek(self):
        &quot;&quot;&quot;返回栈顶元素&quot;&quot;&quot;
        if self.__list:           # 列表为空时，返回None，否则返回最后一个元素
            return self.__list[-1]
        else:
            return None

    def is_empty(self):
        &quot;&quot;&quot;判断栈是否为空&quot;&quot;&quot;
        return not self.__list    # 列表为空时，返回True，否则返回False

    def size(self):
        &quot;&quot;&quot;返回栈的元素个数&quot;&quot;&quot;
        return len(self.__list)

if __name__ == &#39;__main__&#39;:
    s = Stack()
    s.push(1)
    s.push(2)
    s.push(3)
    s.push(4)
    print(&quot;栈顶数据：&quot;, s.peek())
    print(&quot;判空：&quot;, s.is_empty())
    print(&quot;长度：&quot;, s.size())

    print(s.pop())
    print(s.pop())
    print(s.pop())
    print(s.pop())
    print(&quot;栈顶数据：&quot;, s.peek())
    print(&quot;判空：&quot;, s.is_empty())
    print(&quot;长度：&quot;, s.size())
</code></pre>
<p>&nbsp;</p>
</body>
</html>